#### 7.1 Основы Spring. Реактивное программирование в Spring
* 


#### 7.2 Spring WebFlux
* `org.springframework.boot:spring-boot-starter-webflux` - зависимость для webflux, делает ненужным `spring mvc`
* `Mono` - это реактивный тип данных, представляющий ноль или одно значение. Он используется, когда вы ожидаете получить только один элемент данных, например, результат выполнения операции или объект. Однако `Mono` также может использоваться для предоставления ошибок или завершения потока данных
* `Flux` - это реактивный тип данных, представляющий ноль, одно или более значений. `Flux` используется для предоставления множества элементов. Например, список элементов из базы данных, события из входящего потока и т.д.
* `Холодные потоки` - потоки, которые начинают свой процесс генерации данных только тогда, когда на них подписывается подписчик. Для каждого подписчика начинается свой независимый процесс обработки данных, каждый подписчик получает полный набор данных заново, как будто он стартует с нуля.
* `Горячие потоки` - потоки, которые генерируют данные вне зависимости от кол-ва подписчиков. Подписчики, к-е подключаются к горячему потоку, могут получать только те данные, которые были сгенерированы после их подключения.
* `ServerResponse.class` - `ResponseEntity.class` для реактивного ответа `Spring WebFlux`
* `RouterFunction<>.class` - класс, который мы создаём, чтобы замапить вызовы api соответствующим функциям обработки запросов
```java
@Configuration
public class ItemRouter {
    @Bean
    public RouterFunction<ServerResponse> itemRouters(ItemHandler itemHandler) {
        return RouterFunction.route()
                .GET("/api/v1/functions/item", itemHandler::getAllItem)
                .GET("/api/v1/functions/item/{id}", itemHandler::findById)
                .POST("/api/v1/functions/item", itemHandler::createItem)
                .GET("/api/v1/functions/error", itemHandler::errorRequest)
                .build();
    }
}
```
* `DefaultErrorAttributes.class` - позволяет добавлять дополнительные возвращаемые атрибуты ошибок (поля в json-ответе на ошибку)
```java
@Configuration
public class RouterErrorConfiguration {
    @Bean
    public DefaultErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes() { // из пакета org.springframework.boot.web.reactive.error
            @Override
            public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
                Map<String, Object> errorAttributes = super.getErrorAttributes(request, options);
                
                errorAttributes.put("error-attribute", "Error in request!");
                errorAttributes.put("status", HttpStatus.BAD_REQUEST.value());
                
                return errorAttributes;
            }
        };
    }
}
```


#### 7.3 MongoDB
* `NoSQL` - `Not Only SQL` - это общий термин, используемый для обозначения различных типов баз данных, которые отличаются от традиционных реляционных баз данных. Основное отличие `NoSQL` баз данных заключается в том, что они не используют `SQL` для запросов и манипуляция с данными, как это делается в реляционных базах данных. Вместо этого `NoSQL` базы данных предоставляют разные модели данных и методы доступа к данным, чтобы соответствовать конкретным потребностям и сценариям.
  - Гибкая схема данных - NoSQL базы данных позволяют хранить данные различных типов и структур без жёсткой предварительной схемы
  - Горизонтальное масштабирование - многие NoSQL-БД спроектированы для масштабирования горизонтально, что позволяет легко добавлять новые узлы для обработки роста данных
  - Высокая доступность и отказоустойчивость - многие NoSQL-БД разработаны с учётом высокой доступности данных, что позволяет поддерживать непрерывную работы приложений
  - Различные модели данных - NoSQL-БД поддерживают различные модели данных, такие как key-value, документоориентированные, столбцовые, графовые и др.
  - Разное назначение - разные типы NoSQL-БД подходят для различных сценариев, таких как кэширование, хранение больших объёмов данных, аналитика, обработка потоков данных и др.
* Виды `NoSQL`-БД:
  - `Key-value` - `Redis`, `Amazon DynamoDB`
  - `Документоориентированные` БД - `MongoDB`, `Couchbase`, `Firebase Firestore`. - JSON, XML
  - `Столбцовые хранилища` - `Apache Cassandra`, `HBase` - если данные имеют определённую структуру и часто выполняются запросы на чтение или агрегацию данных. Хороши для аналитических приложений, где необходимо быстро анализировать большие объёмы данных
  - `Графовые` БД - `Neo4j`, `Amazon Neptune` - если данные имеют связи и отношения между сущностями, которые лучше представляются в виде графов. Хороши для социальных сетей, рекомендательных систем, анализа связей
* `NoSQL` vs `RDBMS`
  - Модель данных:
    + Реляционные БД: данные хранятся в таблицах с определёнными схемами, состоящими из строк и столбцов. Реляционные БД используют SQL для выполнения операций по извлечению, добавлению, изменению и удалению данных
    + `NoSQL` БД: предлагают разнообразные модели данных. Модели данных `NoSQL` БД более гибкие и могут подстраиваться под конкретные потребности приложения
  - Масштабируемость:
    + Реляционные БД: традиционно масштабируются вертикально (увеличение ресурсов на одном сервере) (Не совсем корректно: распределённые БД могут быть разбиты по секциям, что позволяет масштабировать их горизонтально)
    + `NoSQL` БД: многие `NoSQL` БД разработаны для горизонтального масштабирования (добавление новых серверов для обработки данных )
  - Гибкость:
    + Реляционные БД: требуют определения схемы данных заранее ()
    + NoSQL БД: позволяют более гибкое изменения структуры данных, что особенно полезно в динамичных средах
  - Транзакции и целостность данных:
    + Реляционные БД: обеспечивают строгие транзакции и соблюдение целостности данных, что делает их хорошим выбором для приложений, где это критично
    + NoSQL БД: некоторые NoSQL БД поддерживают ограничение транзакции и целостность данных, но это может быть менее выражено
  - Производительность:
    + Реляционные БД: хорошо подходят для сложных запросов и аналитики, но иногда могут столкнуться с ограничениями производительности в случае больших объёмов данных и высокой нагрузки
    + NoSQL БД: обеспечивают высокую производительность для операций чтения/записи и обработки больших объёмов данных
* `MongoDB` - документоориентированная БД. Разработана для хранения, организации и обработки больших объёмов неструктурированных данных. MongoDB предоставляет механизм хранения данных в виде документов, что делает её удобной для хранения разнообразных типов информации
  - Документоориентированная - данные хранятся в виде документов в формате BSON (бинарно-кодированный JSON). 
  - Гибкая схема данных - не требует заранее определённой схемы данных. Документы с разными схемами могут храниться в одной коллекции
  - Масштабируемость - поддерживает горизонтальное масштабирование путём добавления новых серверов в кластер
  - Операции `CRUD` - предоставляет мощные операции для создания, чтения, обновления и удаления данных
  - Индексы - поддерживает индексы для ускорения операций поиска и запросов
  - Агрегация - предоставляет мощные возможности для агрегации данных, включая группировку, сортировку, фильтрацию и преобразования
  - Транзакции - начиная с версии `4.0`, поддерживает транзакции для обеспечения целостности данных
  - Географические запросы - предоставляет возможности для работы с географическими данными и выполнения гео-запросов
* `application.yml` для `MongoDB`:
```yaml
spring:
  data:
    mongodb:
      uri: mongodb://root:root@localhost:27017/lesson7?authSource=admin
```
* `docker-compose.yml` для `MongoDB`:
```yaml
version: '3.9'

services:
  mongodb:
    image: mongo:6.0.8
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: root
      MONGO_INITDB_DATABASE: appdatabase
```
* `MongoDB CLI command` (внутри контейнера):
  - `use test_db` - создаёт бд `test_db`
  - `db.createCollection("usr")` - создаёт коллекцию `usr` внутри `test_db`
  - `db.usr.insert({name: "John", age: 20})` - создаёт JSON-документ в `test_db`-бд `usr`-коллекции. Метод `deprecated`, лучше использовать `insertOne`, `insertMany` или `bulkWrite`
  - `db.usr.find({age: {$gt: 20}})` - найти все документы, где поле `age` больше(`$gt`), чем `20`
  - `db.usr.update({name: "Paul"}, {$set: {age: 25}})` - найти документ с полем `name` равным `Paul` и вставить в поле `age` этого документа значение `25`
  - `db.usr.deleteOne({name: "John"})` - удалить один документ с полем `name` равным `John`


#### 7.4 Написание приложения с MongoDB и WebFlux
* `org.springframework.boot:spring-boot-starter-data-mongodb-reactive` - зависимость для подключения `MongoDB`
* `@Document` - применяется к классу-сущности, обозначает, что сущность будет использоваться для отображения на документ `MongoDB`
- `@Document(collection = "items")` - явное указание коллекции, в которой будет содержаться сущность
* `@Id` - применяется к полю-первичному ключу в коллекции `MongoDB`
* `@Field` - применяется над полем для указания дополнительной мета-информации для указанного поля
* `ReactiveMongoRepository<EntityType, KeyType>` - репозиторий для поиска сущностей в `MongoDB`, который позволяет возвращать объекты в виде `Mono` и `Flux`
* `MongoRepository<EntityType, KeyType>` - репозиторий для поиска сущностей в `MongoDB` в синхронном стиле
* `Sinks` - 
* `Sinks.Many<EntityType>` - множество реактивных сигналов, которые можно использовать для публикации обновлений. Например, публикации только что созданных объектов
- `Sinks.many().multicast().onBackpressureBuffer()` - создаёт множество с несколькими подписчиками, которые используют для обработки сигналов с `buffer` для хранения тех сигналов, которые подписчики не успели обработать. 
- `Sinks.Many<EntityType>.tryEmitNext(EntityType.class)` - публикует новый сигнал во все подписанные компоненты
* `ServerSentEvent.class` - класс-обёртка для события для клиента
* `MediaType.TEXT_EVENT_STREAM_VALUE` - `text/event-stream` - media type, для стримминга значений от сервера - браузеру в формате текста
* `@ReadOnlyProperty` - помечает, что значение поля не должно быть сериализовано в/десериализовано из `MongoDB`


#### 7.5 Тестирование реактивных компонентов
* `io.projectreactor:reactor-test` - предоставляет удобные компоненты для тестирования реактивных компонентов
* `org.testcontainers:mogodb` - 
* `org.testcontainers:junit-jupiter` - 
* `WebTestClient.class` - позволяет тестировать `endpoints`, созданных с помощью `Spring WebFlux`
* 
